from typing import Dict, Any, List, Union, Callable

from src.misc.config import Config
from src.misc.data_structures import CoachingCard, CoachingLog
from src.inference.dataset_manager import DatasetManager
from src.logging.logger import Logger
from src.misc.types import NumberType


class CoachingCardGenerator(object):
    """
    A class representing a coaching card
    """
    def __init__(self, config: Config, is_debug: bool = False):
        self.config: Config = config
        self.logger: Logger = Logger(self.__class__.__name__, logging_level="debug" if is_debug else "info")

    @staticmethod
    def pct(v: NumberType) -> str:
        """
        Convert any rubric/feature value into a safe percentage string.
        - If value appears to be 0..100, scale to 0..1 first.
        - Clamp to [0,1] to avoid accidental overshoots.
        """
        try:
            x = float(v)
        except Exception:
            x = 0.0
        if x > 1.0:  # treat as 0..100 scale
            x = x / 100.0
        x = max(0.0, min(1.0, x))
        return f"{x * 100:.0f}%"

    @classmethod
    def make_coaching_dict(cls, rubric: dict, features: dict, focus: str) -> CoachingCard:
        """
        Make a coaching card dictionary
        :param rubric: The current rubric scores
        :param features: The current feature scores
        :param focus: The focus skill for improvement
        :return: A coaching card as a dict
        """
        why: str = \
            f"Focus on {focus}: current rubric {cls.pct(rubric.get(focus, 0))}. " \
            f"Signals — CTA={cls.pct(features.get('cta_explicitness', 0))}, " \
            f"Empathy={cls.pct(features.get('empathy_markers', 0))}, " \
            f"Questions={cls.pct(features.get('question_ratio_llm', 0))}."
        exercises: List[str] = [
            "Mirror one concern, then ask an open question.",
            "End with a time-bound, single-step CTA.",
            "Summarize in one sentence before proposing next step.",
        ]
        scenario: Dict[str, Union[str, List[str]]] = {
            "persona": "Busy colleague",
            "opening": "I'm overloaded; can we delay this?",
            "followups": ["I hear the timing is tight—what's the smallest step?",
                          "If we try 15 minutes tomorrow, would that help?"],
            "difficulty": 0.45
        }
        upgrades: List[str] = ["Add a quantifiable benefit.",
                               "Handle a second objection without losing empathy."]
        return CoachingCard(
            focus=focus,
            why=why,
            exercises=exercises,
            scenario=scenario,
            upgrades=upgrades
        )

    def generate(self, rubric: Dict[Any, Any], features: Dict[Any, Any], focus: str) -> CoachingCard:
        """
        Generate a coaching card
        :param rubric: The current rubric scores
        :param features: The current feature scores
        :param focus: The focus skill for improvement
        :return: A coaching card as a dict
        """
        self.logger.debug(f'Rubric: {rubric}, Features: {features}')
        self.logger.info(f'Generating coaching card for focus: {focus}')
        return self.make_coaching_dict(rubric=rubric, features=features, focus=focus)

    def to_json(self, coaching_log: List[CoachingLog], path: str) -> None:
        """
        Write coaching log to JSON file
        :param coaching_log: The coaching log to write
        :param path: The path to write the JSON file to
        :return: None
        """
        self.logger.info(f'Writing coaching log to {path}')
        serialized_coaching_log: List[Dict[str, Any]] = []
        for log in coaching_log:
            serialized_coaching_log.append(log.to_dict())
        DatasetManager._write_json(obj=serialized_coaching_log,
                                   path=path,
                                   encoding=self.config.encoding_protocol)

    def log_coaching_next_from_coaching_log(self, coaching_log: List[CoachingLog]):
        """
        Log a coaching next JSON with the following structure:
        {
            "turn": 0,
            "focus": "clarity",
            "why": "Focus on clarity: current rubric 68%. Signals — CTA=20%, Empathy=40%, Questions=0%.",
            "exercises": ["", ... ],
            "scenario_stub": {
              "persona": "",
              "opening": "",
              "followups": ["", ... ]
        }
        :param coaching_log: The coaching log as it is generated by calculate_policies_rewards()
        :return: None, JSON saved to config.coaching_next_path
        """
        coaching_next: List[Dict[str, Any]] = []
        card: CoachingCard
        for log in coaching_log:
            card = log.card
            coaching_next.append({
                "turn": log.turn,
                "focus": log.focus,
                "why": card.why,
                "exercises": card.exercises,
                "scenario_stub": {
                    "persona": card.scenario.get("persona", ""),
                    "opening": card.scenario.get("opening", ""),
                    "followups": card.scenario.get("followups", []),
                },
                "difficulty_upgrades": card.upgrades
            })

        DatasetManager._write_json(obj=coaching_next,
                                   path=self.config.coaching_next_path,
                                   encoding=self.config.encoding_protocol)


if __name__ == "__main__":
    gen = CoachingCardGenerator(is_debug=True, config=Config())
    rubric = {"clarity": 0.6, "active_listening": 0.5, "call_to_action": 0.4, "friendliness": 0.8, "overall": 70}
    feats = {"cta_explicitness": 0.3, "empathy_markers": 0.4, "question_ratio": 0.2}
    card = gen.generate(rubric=rubric, features=feats, focus="call_to_action")
    assert isinstance(card.why, str) and len(card.why.split()) <= 180, "why must be ≤180 words"
    assert len(card.exercises) == 3, "Need exactly 3 micro-exercises"
    assert "persona" in card.scenario and "opening" in card.scenario and len(card.scenario.get("followups", [])) == 2
    assert len(card.upgrades) == 2
    print("[CoachingCardGenerator] OK:", card.focus)
